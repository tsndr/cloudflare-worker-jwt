import {
	textToArrayBuffer,
	arrayBufferToBase64Url,
	base64UrlToArrayBuffer,
	textToBase64Url,
	importKey,
	decodePayload
} from './utils.js'

if (typeof crypto === 'undefined' || !crypto.subtle)
    throw new Error('SubtleCrypto not supported!')

/**
 * @type {import('./types.ts').JwtAlgorithms}
 */
const algorithms = {
    ES256: { name: 'ECDSA', namedCurve: 'P-256', hash: { name: 'SHA-256' } },
    ES384: { name: 'ECDSA', namedCurve: 'P-384', hash: { name: 'SHA-384' } },
    ES512: { name: 'ECDSA', namedCurve: 'P-521', hash: { name: 'SHA-512' } },
    HS256: { name: 'HMAC', hash: { name: 'SHA-256' } },
    HS384: { name: 'HMAC', hash: { name: 'SHA-384' } },
    HS512: { name: 'HMAC', hash: { name: 'SHA-512' } },
    RS256: { name: 'RSASSA-PKCS1-v1_5', hash: { name: 'SHA-256' } },
    RS384: { name: 'RSASSA-PKCS1-v1_5', hash: { name: 'SHA-384' } },
    RS512: { name: 'RSASSA-PKCS1-v1_5', hash: { name: 'SHA-512' } }
}

/**
 * Signs a payload and returns the token
 * @template [Payload = {}]
 * @template [Header = {}]
 * @param {import('./types.ts').JwtPayload<Payload>} payload - The payload object. To use `nbf` (Not Before) and/or `exp` (Expiration Time) add `nbf` and/or `exp` to the payload.
 * @param {string | JsonWebKey| CryptoKey} secret - A string which is used to sign the payload.
 * @param {import('./types.ts').JwtSignOptions<Header> | import('./types.ts').JwtAlgorithm} [options = 'HS256'] - The options object or the algorithm.
 * @throws {Error} If there's a validation issue.
 * @returns {Promise<string>} Returns token as a `string`.
 */
export async function sign(payload, secret, options) {
    if (typeof options === 'string')
        options = { algorithm: options }

    options = { algorithm: 'HS256', header: /** @type {import('./types.ts').JwtHeader<Header>} */({ typ: 'JWT' }), ...options }

    if (!payload || typeof payload !== 'object')
        throw new Error('payload must be an object')

    if (!secret || (typeof secret !== 'string' && typeof secret !== 'object'))
        throw new Error('secret must be a string, a JWK object or a CryptoKey object')

    if (typeof options.algorithm !== 'string')
        throw new Error('options.algorithm must be a string')

    /** @type {SubtleCryptoImportKeyAlgorithm} */
    const algorithm = algorithms[options.algorithm]

    if (!algorithm)
        throw new Error('algorithm not found')

    if (!payload.iat)
        payload.iat = Math.floor(Date.now() / 1000)

    const partialToken = `${textToBase64Url(JSON.stringify({ ...options.header, alg: options.algorithm }))}.${textToBase64Url(JSON.stringify(payload))}`

    const key = secret instanceof CryptoKey ? secret : await importKey(secret, algorithm, ['sign'])
    const signature = await crypto.subtle.sign(algorithm, key, textToArrayBuffer(partialToken))

    return `${partialToken}.${arrayBufferToBase64Url(signature)}`
}

/**
 * Verifies the integrity of the token and returns a boolean value.
 *
 * @param {string} token - The token string generated by `jwt.sign()`.
 * @param {string | JsonWebKey | CryptoKey} secret - The string which was used to sign the payload.
 * @param {import('./types.ts').JwtVerifyOptions | import('./types.ts').JwtAlgorithm} [options = { algorithm: 'HS256', throwError: false }] - The options object or the algorithm.
 * @throws {Error | string} - Throws an error `string` if the token is invalid or an `Error-Object` if there's a validation issue.
 * @returns {Promise<boolean>} Returns `true` if signature, `nbf` (if set) and `exp` (if set) are valid, otherwise returns `false`.
 */
export async function verify(token, secret, options = { algorithm: 'HS256', throwError: false }) {
    if (typeof options === 'string')
        options = { algorithm: options, throwError: false }

    options = { algorithm: 'HS256', throwError: false, ...options }

    if (typeof token !== 'string')
        throw new Error('token must be a string')

    if (typeof secret !== 'string' && typeof secret !== 'object')
        throw new Error('secret must be a string, a JWK object or a CryptoKey object')

    if (typeof options.algorithm !== 'string')
        throw new Error('options.algorithm must be a string')

    const tokenParts = token.split('.')

    if (tokenParts.length !== 3)
        throw new Error('token must consist of 3 parts')

    /** @type {SubtleCryptoImportKeyAlgorithm} */
    const algorithm = algorithms[options.algorithm]

    if (!algorithm)
        throw new Error('algorithm not found')

    const { payload } = decode(token)

    try {
        if (!payload)
            throw new Error('PARSE_ERROR')

        if (payload.nbf && payload.nbf > Math.floor(Date.now() / 1000))
            throw new Error('NOT_YET_VALID')

        if (payload.exp && payload.exp <= Math.floor(Date.now() / 1000))
            throw new Error('EXPIRED')

        const key = secret instanceof CryptoKey ? secret : await importKey(secret, algorithm, ['verify'])

        return await crypto.subtle.verify(algorithm, key, base64UrlToArrayBuffer(tokenParts[2]), textToArrayBuffer(`${tokenParts[0]}.${tokenParts[1]}`))
    } catch(err) {
        if (options.throwError)
            throw err

        return false
    }
}

/**
 * Returns the payload **without** verifying the integrity of the token. Please use `jwt.verify()` first to keep your application secure!
 *
 * @template [Payload = {}]
 * @template [Header = {}]
 * @param {string} token - The token string generated by `jwt.sign()`.
 * @returns {import('./types.ts').JwtData<Payload, Header>} Returns an `object` containing `header` and `payload`.
 */
export function decode(token) {
    return {
        header: decodePayload(token.split('.')[0].replace(/-/g, '+').replace(/_/g, '/')),
        payload: decodePayload(token.split('.')[1].replace(/-/g, '+').replace(/_/g, '/'))
    }
}

export default {
    sign,
    verify,
    decode
}